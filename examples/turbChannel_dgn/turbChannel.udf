#include "gnn.hpp"

static dfloat ReTau;
static dfloat zLength;
static dfloat xLength;
static dfloat betaY;

#ifdef __okl__

#endif

gnn_t* graph = nullptr;

/* User Functions */

void userf(double time)
{
  auto mesh = nrs->mesh;
  dfloat mue, rho;
  platform->options.getArgs("VISCOSITY", mue);
  platform->options.getArgs("DENSITY", rho);
  const dfloat RE_B = rho / mue;
  const dfloat DPDX = (ReTau / RE_B) * (ReTau / RE_B);

  auto o_FUx = nrs->o_NLT + 0 * nrs->fieldOffset;
  platform->linAlg->fill(mesh->Nlocal, DPDX, o_FUx);
}

void useric(nrs_t *nrs)
{
  auto mesh = nrs->mesh;

  if (platform->options.getArgs("RESTART FILE NAME").empty()) {
    const auto C = 5.17;
    const auto k = 0.41;
    const auto eps = 1e-2;
    const auto kx = 23.0;
    const auto kz = 13.0;
    const auto alpha = kx * 2 * M_PI / xLength;
    const auto beta = kz * 2 * M_PI / zLength;
    dfloat mue;
    platform->options.getArgs("VISCOSITY", mue);

    auto [x, y, z] = mesh->xyzHost();

    std::vector<dfloat> U(mesh->dim * nrs->fieldOffset, 0.0);
    for (int i = 0; i < mesh->Nlocal; i++) {
      const auto yp = (y[i] < 0) ? (1 + y[i]) * ReTau : (1 - y[i]) * ReTau;

      dfloat ux =
          1 / k * log(1 + k * yp) + (C - (1 / k) * log(k)) * (1 - exp(-yp / 11) - yp / 11 * exp(-yp / 3));
      ux *= ReTau * mue;

      U[i + 0 * nrs->fieldOffset] = ux + eps * beta * sin(alpha * x[i]) * cos(beta * z[i]);
      U[i + 1 * nrs->fieldOffset] = eps * sin(alpha * x[i]) * sin(beta * z[i]);
      U[i + 2 * nrs->fieldOffset] = -eps * alpha * cos(alpha * x[i]) * sin(beta * z[i]);
    }
    nrs->o_U.copyFrom(U.data(), U.size());

  }
}

void outfld_wrapper(nrs_t *nrs, std::unique_ptr<iofld> &checkpointWriter, const int N, double time, int tstep, std::string fileName)                                                                                             
{
  if (!checkpointWriter) {
  checkpointWriter = iofldFactory::create("nek"); // or "adios"
  if (platform->comm.mpiRank == 0) {
   printf("create a new iofldFactory... %s\n", fileName.c_str());
  }
 }

 if (!checkpointWriter->isInitialized()) {
  auto visMesh = (nrs->cht) ? nrs->cds->mesh[0] : nrs->mesh;
  checkpointWriter->open(visMesh, iofld::mode::write, fileName);

  if (platform->options.compareArgs("LOWMACH", "TRUE")) {
   checkpointWriter->addVariable("p0th", nrs->p0th[0]);
  }

  if (platform->options.compareArgs("VELOCITY CHECKPOINTING", "TRUE")) {
   std::vector<occa::memory> o_V;
   for (int i = 0; i < visMesh->dim; i++) {
    o_V.push_back(nrs->o_U.slice(i * nrs->fieldOffset, visMesh->Nlocal));
   }
   checkpointWriter->addVariable("velocity", o_V);
  }

  if (platform->options.compareArgs("PRESSURE CHECKPOINTING", "TRUE")) {
   auto o_p = std::vector<occa::memory>{nrs->o_P.slice(0, visMesh->Nlocal)};
   checkpointWriter->addVariable("pressure", o_p);
  }

  for (int i = 0; i < nrs->Nscalar; i++) {
   if (platform->options.compareArgs("SCALAR" + scalarDigitStr(i) + " CHECKPOINTING", "TRUE")) {
    const auto temperatureExists = platform->options.compareArgs("SCALAR00 IS TEMPERATURE", "TRUE");
    std::vector<occa::memory> o_Si = {nrs->cds->o_S.slice(nrs->cds->fieldOffsetScan[i], visMesh->Nlocal)};
    if (i == 0 && temperatureExists) {
     checkpointWriter->addVariable("temperature", o_Si);
    } else {
     const auto is = (temperatureExists) ? i - 1 : i;
     checkpointWriter->addVariable("scalar" + scalarDigitStr(is), o_Si);
    }
   }
  }
 }

 const auto outXYZ = platform->options.compareArgs("CHECKPOINT OUTPUT MESH", "TRUE");
 const auto FP64 = platform->options.compareArgs("CHECKPOINT PRECISION", "FP64");
 const auto uniform = (N < 0) ? true : false;

 checkpointWriter->writeAttribute("polynomialOrder", std::to_string(abs(N)));
 checkpointWriter->writeAttribute("precision", (FP64) ? "64" : "32");
 checkpointWriter->writeAttribute("uniform", (uniform) ? "true" : "false");
 checkpointWriter->writeAttribute("outputMesh", "true");

 checkpointWriter->addVariable("time", time);

 checkpointWriter->process();
}


/* UDF Functions */

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  platform->par->extract("casedata", "ReTau", ReTau);
  platform->par->extract("casedata", "zLength", zLength);
  platform->par->extract("casedata", "xLength", xLength);
  platform->par->extract("casedata", "betaY", betaY);
}

void UDF_Setup()
{
  if (platform->options.compareArgs("CONSTANT FLOW RATE", "FALSE")) {
    nrs->userVelocitySource = &userf;
  }

  useric(nrs);

  // gnn plugin
  graph = new gnn_t(nrs);
  graph->gnnSetup();
  graph->gnnWrite();
}

void UDF_ExecuteStep(double time, int tstep)
{
  // Write flow field
  if (tstep%100==0 && tstep>0) {
    int rank, size;
    MPI_Comm_rank(platform->comm.mpiComm, &rank);
    MPI_Comm_size(platform->comm.mpiComm, &size);
    dlong n_nodes = graph->mesh->Np * graph->mesh->Nelements;
    std::string irank = "_rank_" + std::to_string(rank);
    std::string nranks = "_size_" + std::to_string(size);
    std::cout << "n_nodes: " << n_nodes << "\t fieldOffset: " << graph->fieldOffset << std::endl;
  
    dfloat time_rounded = std::round(time * 10.0) / 10.0;
    std::ostringstream outStream;
    outStream << std::fixed << std::setprecision(1) << time_rounded;
    std::string time_rounded_string = outStream.str();

    dfloat *U = new dfloat[graph->mesh->dim * graph->fieldOffset]();
    graph->interpolateField(nrs, nrs->o_U, U, graph->mesh->dim);
    writeToFileBinaryF(graph->writePath + "/fld_u_time_" + time_rounded_string + irank + nranks + ".bin",
                U, graph->fieldOffset, 3);
  }

  if (nrs->lastStep) {
    delete graph;
  }
}
